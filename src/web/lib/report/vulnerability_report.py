# pylint: disable=missing-function-docstring

import json
import logging
from collections.abc import Iterable
from pathlib import Path
from typing import Any, Optional, TypedDict

from lib.report import (
    MissingFieldError,
    capitalize_and_fix_spaces,
    format_date,
    get_cvss_severity,
)
from lib.report.report_item import (
    EventsGeneration,
    ReportItem,
    VulnerabilityReportIntro,
)


class VulnerabilityReportState(TypedDict):
    """
    Type for the state of VulnerabilityReportClass used to pickle.
    """

    report: dict[str, Any]


class VulnerabilityReport:
    """
    This class represents a report about vulnerability from Taranis.
    """

    def __init__(self, path: str | Path) -> None:
        with open(path, encoding="utf-8") as f:  # noqa: PTH123
            self.report = json.load(f)
        self._build_reports_items()
        self.validate()

    def _build_reports_items(self) -> None:
        self.items = []
        self.intro = None
        for item in self.report.get("report_items", []):
            if item.get("type") == "Vulnerability Report - Intro":
                self.intro = VulnerabilityReportIntro(item)
            else:
                self.items.append(ReportItem(item))

    def __getstate__(self) -> VulnerabilityReportState:
        """
        Returns data needed for caching this object.
        """
        return {"report": self.report}

    def __setstate__(self, state: VulnerabilityReportState) -> None:
        """
        Creates this object from pickled (cached) data.
        """
        self.report = state["report"]
        self._build_reports_items()

    def validate(self) -> None:
        """
        Does the basic report validation from the input JSON.
        Mostly just if the field is there, not if the content is correct.
        """
        # These methods will fail if something is missing.
        self.get_id()
        self.get_title()
        self.get_tlp()
        self.get_publish_date()
        self.get_author()
        assert self.report.get("report_items", None) is not None, "Report items field is missing!"
        assert self.get_tlp() in ["CLEAR"], f"TLP {self.get_tlp()} should not be published!"

    def validate_versions(self, logger: Optional[logging.Logger] = None) -> None:
        """
        Validate all versions in report items and send an e-mail
        about all issues that were found.
        """
        for item in self.items:
            item.validate_versions(send_mail=True, logger=logger)

    def _get_from_product(self, field: str, invalid_value: Any = None, required: bool = False) -> Any:
        """
        Helper method for getting 'field' from product part of the report.
        'Invalid_value' specifies what to return if the field is missing.
        If required is True, Error is thrown if the field is missing.
        """
        product = self.report.get("product", None)
        if product is None:
            raise MissingFieldError("product", self)
        if product.get(field) is None and required:
            raise MissingFieldError(field, self)
        return product.get(field, invalid_value)

    def get_id(self) -> str:
        return self._get_from_product("id", required=True)

    def get_title(self) -> str:
        return capitalize_and_fix_spaces(self._get_from_product("title", required=True))

    def get_tlp(self) -> str:
        return self._get_from_product("max_tlp", required=True).upper()

    def get_formatted_tlp(self, with_space: bool = False) -> str:
        """
        Formats the TLP of the report into '[TLP:CLEAR]' format.
        If with_space is True, add a space at the end of the string.
        """
        return f"[TLP:{self.get_tlp()}]" + (" " if with_space else "")

    def get_description(self) -> Optional[str]:
        if (description := self._get_from_product("description")) is None:
            return None
        return capitalize_and_fix_spaces(description)

    def should_generate_events(self) -> EventsGeneration:
        if self.intro:
            return self.intro.should_generate_events()
        return EventsGeneration.TEST

    def get_intro_description(self) -> Optional[str]:
        if not self.intro or self.intro.get_description() is None:
            return None
        return capitalize_and_fix_spaces(self.intro.get_description())

    def get_one_description(self) -> str:
        return self.get_intro_description() or self.get_description() or ""

    def get_publish_date(self) -> str:
        return format_date(self._get_from_product("date", required=True))

    def get_author(self) -> str:
        """
        Returns the name of the report author,
        or throws an Exception if it is missing.
        """
        user = self._get_from_product("user", required=True)
        if user.get("name") is None:
            raise MissingFieldError("name of the author", self)
        return user.get("name")

    def get_author_username(self) -> Optional[str]:
        """
        Returns the name of the report author,
        or None if one of the fields is missing.
        """
        if self._get_from_product("user") is None:
            return None
        return self._get_from_product("user").get("username", None)

    def get_report_items(self) -> list[ReportItem]:
        """
        Returns a list of report items represented by ReportItem class.
        """
        return self.items

    def get_links(self, item_indices: Optional[Iterable[int]] = None) -> list[Optional[str]]:
        """
        Returns a list of links from the vulnerability report.
        Links that do not appear in at least one report item specified by
        the item_indices, or in the intro, are replaced by None.
        """
        links = self._get_from_product("links", required=True)
        # If item_indices is unspecified or empty, return all links.
        if not item_indices:
            return links
        # At first, all links are None in result_links list. If some link
        # appears, then it replaces the None value on its index.
        result_links: list[Optional[str]] = [None] * len(links)
        if self.intro:
            for link in self.intro.get_links():
                result_links[links.index(link)] = link
        # Iterate through the links from the specified report items.
        for i in item_indices:
            if i - 1 < len(self.items):
                for link in self.items[i - 1].get_links():
                    result_links[links.index(link)] = link
        return result_links

    def get_CVEs(self, item_indices: Optional[Iterable[int]] = None) -> list[str]:
        """
        Returns a list of CVEs from the report items defined by item_indices,
        and add "cve:" namespace to them.
        This is useful for IDEA message generation.
        """
        result_set: set[str] = set()
        for i, item in enumerate(self.get_report_items()):
            if not item_indices or i + 1 in item_indices:
                result_set = result_set.union(item.get_CVEs())
        return sorted(["cve:" + cve for cve in result_set])

    def get_CWEs(self) -> set[str]:
        """
        Returns a set of all CWEs from the report items.
        """
        result_set: set[str] = set()
        for item in self.get_report_items():
            result_set = result_set.union(item.get_CWEs())
        return {"CWE-" + cve for cve in result_set}

    def get_max_cvss_number(self, item_indices: Optional[Iterable[int]] = None) -> Optional[float]:
        """
        Returns the largest CVSS score number from all the specified report items,
        or from all report items, if item_indices argument was not specified.
        If there are no CVSS scores in the report items, return None.
        """
        if item_indices is not None:
            cvss_numbers = [cvss for item in item_indices if (cvss := self.items[item - 1].get_cvss_number()) is not None]
        else:
            cvss_numbers = [cvss for item in self.items if (cvss := item.get_cvss_number()) is not None]
        if cvss_numbers:
            return max(cvss_numbers)
        return None

    def matches_keyword(self, keyword: str) -> bool:
        """
        Returns if the keyword is somewhere in the report.
        """
        for text in [
            self.get_title(),
            self.get_intro_description(),
            self.get_description(),
            self.get_id(),
            self.get_formatted_tlp(with_space=True),
            self.get_author(),
            " ".join(self.get_CVEs()),
            " ".join(self.get_CWEs()),
            self.get_publish_date(),
            self.get_max_cvss_number(),
            get_cvss_severity(self.get_max_cvss_number()),
        ]:
            if text and keyword.lower().strip() in str(text).lower():
                return True
        return False
